/* Correctly-rounded atan2pi function for two binary64 values.

Copyright (c) 2023-2025 Paul Zimmermann

This file is part of the CORE-MATH project
(https://core-math.gitlabpages.inria.fr/).

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/* This implementation is derived from the CORE-MATH atan2.c code
   (branch pz_atan2, revision 1ced4a8), using the formula
   atan2pi (y, x) = atan2(y, x) / pi.
   The parts specific to atan2pi are marked either with "atan2pi_specific",
   or enclosed between "atan2pi_begin" and "atan2pi_end", to make it easier
   to maintain this code if atan2 is fixed or improved.
*/

#include <stdio.h>
#include <stdint.h>
#include <math.h> // needed to provide atan2pi() since glibc does not have it
#include <errno.h>
#include <libm-alias-double.h>
#include "tint.h"

#define MASK 0x7fffffffffffffffull // 2^63-1 (mask the sign bit)

// assume sign bit was removed
static inline int is_nan (uint64_t u)
{
  uint64_t e = u >> 52;
  return e == 0x7ff && u != (e << 52);
}

// assume sign bit was removed
static inline int is_inf (uint64_t u)
{
  return u == (0x7ffull << 52);
}

// ONE_OVER_PI_H+ONE_OVER_PI_L approximates 1/pi with rel. error < 2^-107.871
#define ONE_OVER_PI_H 0x1.45f306dc9c883p-2
#define ONE_OVER_PI_L -0x1.6b01ec5417056p-56

/* The following polynomials z*P(z) and Q(z) are a rational approximation
   of atan(z) on [0,1] generated by the test_atan program from
   rminimax (revision 94902ef):
   The relative approximation error output by rminimax is:
   fpminimax error = 3.99613e-59 (this is the relative error for P(x)/Q(x)
   with respect to atan(x)/x, which equals the relative error for x*P(x)/Q(x)
   with respect to atan(x)).
   The content of the output file atan_fpminimax.sollya is the following
   (Numerator is P(x), and Denominator is Q(x)):
Numerator = [|
0x2.09c0fe2d4c44bb29c73989e7519ea91406726ca119adbfp-12,
0xb.3cf74b427d53e03ee590b839e751890f2570b12bcb2381ap-12,
0x2.c21262c5ee230e68478de0875e1363e89e56c52e12e75e3p-8,
0x7.ea5d53dda9586c1d92a12df585026e1c90046cfd9a5b47f8p-8,
0x1.2ca8329170bf670dc1702b59c84b50b37d942f8d3769ef4p-4,
0x2.5aaa9752ebff1643c8f6de0edb933954b15381534eda7df8p-4,
0x4.1e6a0dafd431588d6c7ceb71f5cec19a77a386c00fd01e5p-4,
0x6.5de3ba90cbe60835e3367d9f6f7d371ab4597cf27f5c488p-4,
0x8.cf8f7c585767042cd92a5b9ac13d8c8043bd4a023dbe04dp-4,
0xa.fdc36d6b36139bf11df63474e3859d442b30b2c089a2b6cp-4,
0xc.6f8fb14638225192f9f04cf55c103771c44675c6d483606p-4,
0xc.ce79f10f754e31591ce47edcbc8a4eeb2a6f721ac656b42p-4,
0xc.090384dbd77132e1dfb4d9a1d595de7e506ca899a394f7p-4,
0xa.556ac9eee25e867d84dafa25141d203f1c7c2a5156b3ec3p-4,
0x8.1bd2677ddfcbc381df33f27dbb60939cb4c2c73286a6c29p-4,
0x5.cf6890b4eb9746ce40ecaee7789e113cba5cabcb5c9e199p-4,
0x3.cb7db6a1d6d99beb0a774e9a709d31960ee49825db23c314p-4,
0x2.40b4d3536e443b61bcfb377f5abc2a7e3a5435f9c2a3a6c8p-4,
0x1.35df4832c39c240f59a062ecccea6ea27d5e854a7f98ca68p-4,
0x9.5db9977c5e6e26385367a63fab8a720fc2b63bd115998d8p-8,
0x4.0be5b6c11b6afa6b863c0af94484ecd862a74b8aae890acp-8,
0x1.8bdd8845186a4130f13cad7c3bdd36cf744b7b5025259982p-8,
0x8.40c38ccfcb5dc64b55a44095bf7f3126668b8792d4ecd08p-12,
0x2.5c1d2bdeca1ac67b082ab087cc4c3c74da7a7f6f75214a28p-12,
0x9.054011c32d4b7a5c68d3c5d525f4af4eeb3c98615dee188p-16,
0x1.bbb6945d5565762aea6ec351e1d3551a7e40c419a7c0eb76p-16,
0x4.077cd0d9f2cd5f28c7357f0328fefa4e8e0194f353816ce8p-20,
0x6.50b6ea4e69842a65d6c651bca00813e0fe3fa3cc2a4378bp-24,
0x5.05d00dc3a15d400f36e0a54a8b6bf820fa981ec3c482e978p-28,
-0x1.38088112d9cca2b819e68e1f4fe2158753b900d05822353ap-60|];
Denominator = [|
0x2.09c0fe2d4c44bb29c73989e7519ea91406726ca119adbfp-12,
0xb.3cf74b427d53e03ee590b839e751890f2570b12bcb238cfp-12,
0x2.ccf112bc350f27a3d109be11851c076e5e7927716e161108p-8,
0x8.264d256f0bf4d61ee21431cc0f29764ce0cc1b593ac9952p-8,
0x1.3b2f8928ed0f65ddde810f893bbca452e8578dc057f6dbfp-4,
0x2.83e22371eaae527bd88fc66b104f6c8e151d128593dc3b34p-4,
0x4.7ece38b955841470d4fb97d6d7e1efdd7cb50c07514b8bcp-4,
0x7.1c0b45bc528f70ab02523c0ae4048f5cfd5521189747598p-4,
0xa.164ccdbb65ee133e623433c5e086402cb228afd335a245fp-4,
0xc.ed0c0cbe44fac2fd7c2adfc7c5dda9ea22b4a311cf5a5b1p-4,
0xf.0e6660438c903713dca1a0f58f0d9438a92b9de68c4488cp-4,
0x1p+0,
0xf.8ea68f9ad849103b257e4bfc606967f818fa2816928c4aap-4,
0xd.dc64eeee350623447a33ea40a2b22e4a6a2c129ace2470ap-4,
0xb.52ddfba2d37c8e224551a9b19fa064a3d78c68b54bc385p-4,
0x8.7ac113d26b683a14e97756c38785b0bf75f0a4506931ba8p-4,
0x5.d0328385c8079eaf24ec7cf91c78f75b402ea46b3f8ee6c8p-4,
0x3.a40b4a92ff0891065173f9b20e96e0a1467aed15fe33328p-4,
0x2.1390172457ddda6c3eabcd30f14774e6a5fe82ba64e0b24cp-4,
0x1.12db48d8fcd9d767c15f816db67b77ea0c399fedcf1dffe8p-4,
0x8.01a0c1a0dfefc92f8e0a97902e08d4781898e0b7d8ef0bcp-8,
0x3.56742224c37c1f6ea32c00086127eebfe033246a82f77e24p-8,
0x1.3b6ad4d3096ee4639ef840e9c09012b2662dd954d548c09cp-8,
0x6.5ba286ceb1697344bc3da132cbbe8025d30ae77005420eb8p-12,
0x1.c254a5c056c9647d2f92273519dae2d8e142ed5a56be2da4p-12,
0x6.82bdb6848076986af025d8bf5c3cd2f11f689adb05f5038p-16,
0x1.363e39445fdef5ca334d0fe1480e7ddc0b5399791828af16p-16,
0x2.bae9c43c14eab0ecc3a975bec45bddd62a6f3fbd5a63e3c4p-20,
0x4.25cd6d03b66803e89f2a803039fbb58a67a12ccb411479fp-24,
0x3.3292e4119e1a4df48cf079a47049f07fd24f82de8f791668p-28|];
*/
static const tint_t P[30] = {
   {.h=0x82703f8b53112eca, .m=0x71ce6279d467aa45, .l=0x19c9b28466b6fc0, .ex=-10, .sgn=0},
   {.h=0xb3cf74b427d53e03, .m=0xee590b839e751890, .l=0xf2570b12bcb2381a, .ex=-8, .sgn=0},
   {.h=0xb08498b17b88c39a, .m=0x11e37821d784d8fa, .l=0x2795b14b84b9d78c, .ex=-6, .sgn=0},
   {.h=0xfd4baa7bb52b0d83, .m=0xb25425beb0a04dc3, .l=0x92008d9fb34b68ff, .ex=-5, .sgn=0},
   {.h=0x96541948b85fb386, .m=0xe0b815ace425a859, .l=0xbeca17c69bb4f7a0, .ex=-3, .sgn=0},
   {.h=0x96aaa5d4baffc590, .m=0xf23db783b6e4ce55, .l=0x2c54e054d3b69f7e, .ex=-2, .sgn=0},
   {.h=0x83cd41b5fa862b11, .m=0xad8f9d6e3eb9d833, .l=0x4ef470d801fa03ca, .ex=-1, .sgn=0},
   {.h=0xcbbc7752197cc106, .m=0xbc66cfb3edefa6e3, .l=0x568b2f9e4feb8910, .ex=-1, .sgn=0},
   {.h=0x8cf8f7c585767042, .m=0xcd92a5b9ac13d8c8, .l=0x43bd4a023dbe04d, .ex=0, .sgn=0},
   {.h=0xafdc36d6b36139bf, .m=0x11df63474e3859d4, .l=0x42b30b2c089a2b6c, .ex=0, .sgn=0},
   {.h=0xc6f8fb1463822519, .m=0x2f9f04cf55c10377, .l=0x1c44675c6d483606, .ex=0, .sgn=0},
   {.h=0xcce79f10f754e315, .m=0x91ce47edcbc8a4ee, .l=0xb2a6f721ac656b42, .ex=0, .sgn=0},
   {.h=0xc090384dbd77132e, .m=0x1dfb4d9a1d595de7, .l=0xe506ca899a394f70, .ex=0, .sgn=0},
   {.h=0xa556ac9eee25e867, .m=0xd84dafa25141d203, .l=0xf1c7c2a5156b3ec3, .ex=0, .sgn=0},
   {.h=0x81bd2677ddfcbc38, .m=0x1df33f27dbb60939, .l=0xcb4c2c73286a6c29, .ex=0, .sgn=0},
   {.h=0xb9ed12169d72e8d9, .m=0xc81d95dcef13c227, .l=0x974b95796b93c332, .ex=-1, .sgn=0},
   {.h=0xf2df6da875b666fa, .m=0xc29dd3a69c274c65, .l=0x83b9260976c8f0c5, .ex=-2, .sgn=0},
   {.h=0x902d34d4db910ed8, .m=0x6f3ecddfd6af0a9f, .l=0x8e950d7e70a8e9b2, .ex=-2, .sgn=0},
   {.h=0x9aefa41961ce1207, .m=0xacd0317666753751, .l=0x3eaf42a53fcc6534, .ex=-3, .sgn=0},
   {.h=0x95db9977c5e6e263, .m=0x85367a63fab8a720, .l=0xfc2b63bd115998d8, .ex=-4, .sgn=0},
   {.h=0x817cb6d8236d5f4d, .m=0x70c7815f28909d9b, .l=0xc54e97155d12158, .ex=-5, .sgn=0},
   {.h=0xc5eec4228c352098, .m=0x789e56be1dee9b67, .l=0xba25bda81292ccc1, .ex=-7, .sgn=0},
   {.h=0x840c38ccfcb5dc64, .m=0xb55a44095bf7f312, .l=0x6668b8792d4ecd08, .ex=-8, .sgn=0},
   {.h=0x97074af7b286b19e, .m=0xc20aac21f3130f1d, .l=0x369e9fdbdd48528a, .ex=-10, .sgn=0},
   {.h=0x9054011c32d4b7a5, .m=0xc68d3c5d525f4af4, .l=0xeeb3c98615dee188, .ex=-12, .sgn=0},
   {.h=0xdddb4a2eaab2bb15, .m=0x753761a8f0e9aa8d, .l=0x3f20620cd3e075bb, .ex=-15, .sgn=0},
   {.h=0x80ef9a1b3e59abe5, .m=0x18e6afe0651fdf49, .l=0xd1c0329e6a702d9d, .ex=-17, .sgn=0},
   {.h=0xca16dd49cd30854c, .m=0xbad8ca379401027c, .l=0x1fc7f47985486f16, .ex=-21, .sgn=0},
   {.h=0xa0ba01b8742ba801, .m=0xe6dc14a9516d7f04, .l=0x1f5303d878905d2f, .ex=-25, .sgn=0},
   {.h=0x9c0440896ce6515c, .m=0xcf3470fa7f10ac3, .l=0xa9dc80682c111a9d, .ex=-59, .sgn=1},
};

static const tint_t Q[30] = {
   {.h=0x82703f8b53112eca, .m=0x71ce6279d467aa45, .l=0x19c9b28466b6fc0, .ex=-10, .sgn=0},
   {.h=0xb3cf74b427d53e03, .m=0xee590b839e751890, .l=0xf2570b12bcb238cf, .ex=-8, .sgn=0},
   {.h=0xb33c44af0d43c9e8, .m=0xf4426f84614701db, .l=0x979e49dc5b858442, .ex=-6, .sgn=0},
   {.h=0x8264d256f0bf4d61, .m=0xee21431cc0f29764, .l=0xce0cc1b593ac9952, .ex=-4, .sgn=0},
   {.h=0x9d97c4947687b2ee, .m=0xef4087c49dde5229, .l=0x742bc6e02bfb6df8, .ex=-3, .sgn=0},
   {.h=0xa0f888dc7aab949e, .m=0xf623f19ac413db23, .l=0x854744a164f70ecd, .ex=-2, .sgn=0},
   {.h=0x8fd9c7172ab0828e, .m=0x1a9f72fadafc3dfb, .l=0xaf96a180ea297178, .ex=-1, .sgn=0},
   {.h=0xe38168b78a51ee15, .m=0x604a47815c8091eb, .l=0x9faaa42312e8eb30, .ex=-1, .sgn=0},
   {.h=0xa164ccdbb65ee133, .m=0xe623433c5e086402, .l=0xcb228afd335a245f, .ex=0, .sgn=0},
   {.h=0xced0c0cbe44fac2f, .m=0xd7c2adfc7c5dda9e, .l=0xa22b4a311cf5a5b1, .ex=0, .sgn=0},
   {.h=0xf0e6660438c90371, .m=0x3dca1a0f58f0d943, .l=0x8a92b9de68c4488c, .ex=0, .sgn=0},
   {.h=0x8000000000000000, .m=0x0, .l=0x0, .ex=1, .sgn=0},
   {.h=0xf8ea68f9ad849103, .m=0xb257e4bfc606967f, .l=0x818fa2816928c4aa, .ex=0, .sgn=0},
   {.h=0xddc64eeee3506234, .m=0x47a33ea40a2b22e4, .l=0xa6a2c129ace2470a, .ex=0, .sgn=0},
   {.h=0xb52ddfba2d37c8e2, .m=0x24551a9b19fa064a, .l=0x3d78c68b54bc3850, .ex=0, .sgn=0},
   {.h=0x87ac113d26b683a1, .m=0x4e97756c38785b0b, .l=0xf75f0a4506931ba8, .ex=0, .sgn=0},
   {.h=0xba065070b900f3d5, .m=0xe49d8f9f238f1eeb, .l=0x6805d48d67f1dcd9, .ex=-1, .sgn=0},
   {.h=0xe902d2a4bfc22441, .m=0x945cfe6c83a5b828, .l=0x519ebb457f8ccca0, .ex=-2, .sgn=0},
   {.h=0x84e405c915f7769b, .m=0xfaaf34c3c51dd39, .l=0xa97fa0ae99382c93, .ex=-2, .sgn=0},
   {.h=0x896da46c7e6cebb3, .m=0xe0afc0b6db3dbbf5, .l=0x61ccff6e78efff4, .ex=-3, .sgn=0},
   {.h=0x801a0c1a0dfefc92, .m=0xf8e0a97902e08d47, .l=0x81898e0b7d8ef0bc, .ex=-4, .sgn=0},
   {.h=0xd59d088930df07db, .m=0xa8cb00021849fbaf, .l=0xf80cc91aa0bddf89, .ex=-6, .sgn=0},
   {.h=0x9db56a6984b77231, .m=0xcf7c2074e0480959, .l=0x3316ecaa6aa4604e, .ex=-7, .sgn=0},
   {.h=0xcb7450d9d62d2e68, .m=0x9787b4265977d004, .l=0xba615cee00a841d7, .ex=-9, .sgn=0},
   {.h=0xe12a52e02b64b23e, .m=0x97c9139a8ced716c, .l=0x70a176ad2b5f16d2, .ex=-11, .sgn=0},
   {.h=0xd057b6d0900ed30d, .m=0x5e04bb17eb879a5e, .l=0x23ed135b60bea070, .ex=-13, .sgn=0},
   {.h=0x9b1f1ca22fef7ae5, .m=0x19a687f0a4073eee, .l=0x5a9ccbc8c14578b, .ex=-15, .sgn=0},
   {.h=0xaeba710f053aac3b, .m=0x30ea5d6fb116f775, .l=0x8a9bcfef5698f8f1, .ex=-18, .sgn=0},
   {.h=0x84b9ada076cd007d, .m=0x13e55006073f76b1, .l=0x4cf4259968228f3e, .ex=-21, .sgn=0},
   {.h=0xcca4b9046786937d, .m=0x233c1e691c127c1f, .l=0xf493e0b7a3de459a, .ex=-26, .sgn=0},
};

// use a type [29,29] rational approximation of atan(z) for 0 <= z <= 1
static double __attribute__((noinline))
atan2pi_accurate (double y, double x)
{
  double absy = __builtin_fabs (y), absx = __builtin_fabs (x);
  int inv = absy > absx;
  if (absy == absx)
    return (y > 0) ?
      ((x > 0) ? 0.25 : 0.75)      // 1st and 2nd quadrant
      : ((x < 0) ? -0.75 : -0.25); // 3rd and 4th quadrant
  tint_t z[1], p[1], q[1];
  if (inv) // case |y| > |x|
  {
    // atan2pi_begin
    // avoid spurious underflow in div_tint_d() below
    d64u64 vx = {.f = x}, vy = {.f = y};
    int ex = (vx.u >> 52) & 0x7ff, ey = (vy.u >> 52) & 0x7ff;
    /* For |y/x| large, atan2pi(y,x) is close to 1/2 or -1/2. More precisely,
       for z > 0x1.45f306dc9c882p+53, atanpi(z) rounds to 1/2 to nearest.
       When x < 0, since atan2pi(y,x) > 1/2 for y>0, we get 1/2 for even a
       smaller value of |y/x|.
       If y is normal, then 2^(ey-1023) <= |y| < 2^(ey-1022), and whatever
       x is normal or subnormal, |x| < 2^(ex-1022), thus
       |y/x| > 2^(ey-ex-1) thus if ey - ex > 54, |y/x| > 2^54.
       If y is subnormal, then x is subnormal too since we are in the case
       |y| > |x|, thus ey = ex, and the test below never holds. */
    if (ey - ex > 54) // |y/x| > 2^54
    {
      if (x > 0)
        return (y > 0) ? 0.5 - 0x1p-55 : -0.5 + 0x1p-55;
      else
        return (y > 0) ? 0.5 + 0x1p-54 : -0.5 - 0x1p-54;
    }
    // atan2pi_end
    div_tint_d (z, x, y);
  }
  else // |x| >= |y|
  {
    // atan2pi_begin
    if (x < 0) {
      // avoid spurious underflow in div_tint_d() below
      d64u64 vx = {.f = x}, vy = {.f = y};
      int ex = (vx.u >> 52) & 0x7ff, ey = (vy.u >> 52) & 0x7ff;
      /* For |y/x| small and x < 0, atan2pi(y,x) is close to 1 or -1.
         More precisely,
         for z <= 0x1.921fb54442d18p-53, 1-atanpi(z) rounds to 1 to nearest.
         If x is normal, then 2^(ex-1023) <= |x| < 2^(ex-1022), and whatever
         y is normal or subnormal, |y| < 2^(ey-1022), thus
         |y/x| < 2^(ey-ex+1) thus if ey - ex < -54, |y/x| < 2^-54.
         If x is subnormal, then y is subnormal too since we are in the case
         |x| >= |y|, thus ex = ey, and the test below never holds. */
      if (ey - ex < -54) // |y/x| < 2^-54
        return (y > 0) ? 1.0 - 0x1p-54 : -1.0 + 0x1p-54;
    }
    // atan2pi_end
    div_tint_d (z, y, x);
  }
  // below when we write y/x it should be read x/y when |x/y| < 1
  // |z - y/x| < 2^-185.53 * |z| (relative error from div_tint_d)
  // the rational approximation is only for z > 0, it is not antisymmetric
  int sz = z->sgn;
  z->sgn = 0;
  cp_tint (p, P + 29);
  cp_tint (q, Q + 29);
  for (int i = 28; i >= 0; i--)
  {
    mul_tint (p, p, z);
    mul_tint (q, q, z);
    add_tint (p, p, P + i);
    add_tint (q, q, Q + i);
  }
  // multiply p by z
  mul_tint (p, p, z);
  /* The routine errPsplit(e,13) in atan2.sage gives a relative error bound
     of 2^-184.14 for |p - z*P(z)|, for -11 <= e <= 0, which corresponds
     to 2^-12 <= z <= 1. */
  /* The routine errQsplit(e,12) in atan2.sage gives a relative error bound
     of 2^-184.19 for |q - Q(z)|, for -11 <= e <= 0, which corresponds
     to 2^-12 <= z <= 1. */
  // divide p by q
  div_tint (z, p, q);
  /* The relative error of div_tint() is <= 2^-185.53, thus we have:
     z*P(z)/Q(z) = atan(z) * (1 + eps0) with |eps0| < 3.99613e-59
     z = y/x * (1 + eps1) with |eps1| < 2^-185.53
     p = z*P(z) * (1 + eps2) with |eps2| < 2^-184.14
     q = Q(z) * (1 + eps3)   with |eps3| < 2^-184.19
     newz = p/q * (1 + eps4) with |eps4| < 2^-185.53
     The equality z = y/x * (1 + eps1) gives
     atan(z) = atan(y/x) + eps1*y/x * 1/(1+theta^2) for theta in (z,y/x).
     Thus |atan(z) - atan(y/x)| <= |eps1*y/x| which yields
     |atan(z) - atan(y/x)|/|atan(y/x)| <= |eps1*y/x|/|atan(y/x)|
     Since t/atan(t) is bounded by 1/atan(1) for 0 <= x <= 1, this yields:
     atan(z) = atan(y/x) * (1 + eps5) with |eps5| <= eps1/atan(1) < 2^-185.18.
     In summary we have:
     newz = atan(y/x)*(1+eps0)*(1+eps2)*(1+eps4)*(1+eps5)/(1+eps3)
     thus:
     newz = atan(y/x)*(1+eps6) with |eps6| < 2^-182.63.
     This corresponds to a maximal error of 2^-182.63*2^192 <= 662 ulps.
  */
  // atan2pi_begin
  // multiply by 1/pi
  mul_tint (z, z, &ONE_OVER_PI);
  /* Since z_in = atan(y/x)*(1+eps6) with |eps6| < 2^-182.63,
     ONE_OVER_PI = 1/pi * (1 + eps7) with |eps7| < 2^-198.59,
     and z_out = z_in * ONE_OVER_PI * (1 + eps8) with |eps8| < 2^-187.67,
     we deduce:
     z_out = atan(y/x)/pi * (1+eps9) with
     |eps9| < (1+eps6)*(1+eps7)*(1+eps8) - 1 < 2^-182.586.
     This corresponds to a maximal error of 2^-182.586*2^192 <= 683 ulps.
  */
  uint64_t err = 683; // error bound in case inv=0 and x > 0, atan2pi_specific
  z->sgn = sz; // restore sign
  /* Now z approximates atanpi(y/x) for inv=0, and atanpi(x/y) for inv=1,
     with -1/4 < z < 1/4.
  */
  if (inv)
  {
    // if x/y > 0 thus atan(x/y) > 0 we apply 1/2 - atanpi(x/y)
    // if x/y < 0 thus atan(x/y) < 0 we apply -1/2 - atanpi(x/y)
    if (z->sgn == 0) { // 0 < atanpi(x/y) < 1/4
      z->sgn = 1;
      add_tint (z, &ONE_HALF, z);
      /* Now 1/4 < z < 1/2. The absolute error on z was bounded by
         2^-182.586*1/4, ONE_HALF is exact, and the add_tint() error is
         bounded by 2 ulp(1/2) = 2^-191,
         which yields a total error < 2^-182.586*1/4 + 2^-191
         < 2^-184.569. Relatively to ulp(1/4) this is less than 346. */
    }
    else // -1/4 < atanpi(x/y) < 0
    {
      add_tint (z, &ONE_HALF, z);
      z->sgn = 1;
      /* Now -1/2 < z < -1/4. The same error analysis as above applies,
         thus we get the same bound of 346 ulps. */
    }
    err = 346;
  }
  // now -1/2 < z < 1/2
  // if x is negative we go to the opposite quadrant
  if (x < 0) {
    if (z->sgn == 0) { // 1st quadrant -> 3rd quadrant (subtract 1)
      z->sgn = 1;
      add_tint (z, &ONE, z);
      z->sgn = 1;
      /* We had 0 < z < 1/2 thus now -1 < z < -1/2.
         The absolute error on z was bounded by max(2^-182.586*1/4,2^-184.569)
         = 2^-184.569, ONE is exact, and the add_tint() error is bounded by
         2 ulp(1) = 2^-190, which yields a total error
         < 2^-184.569 + 2^-190 < 2^-184.535.
         Relatively to ulp(1/2) this is less than 177 ulps. */
    }
    else // 4th quadrant -> 2nd quadrant (add pi)
    {
      add_tint (z, &ONE, z);
      /* We had -1/2 < z < 0 thus now 1/2 < z < 1.
         The same analysis as above applies, and we get the same bound
         of 177 ulps. */
    }
    err = 177;
  }
  // atan2pi_end
  return tint_tod (z, err, y, x);
}

/* The following are degree-7 polynomials approximating atan(x) on (0,1+1/64).
   The polynomial p[i] is for the range [i/64,(i+1)/64], with origin Xfast[i]
   at the middle of that range (except for i=0).
   The coefficients of degree 0 and 1 are double-doubles
   while the other coefficients are doubles. Each line contains as comment the
   index i, and the relative error produced by Sollya, for example 62.976
   for i=1 means that the relative error is 2^-62.976.
   The polynomial for i=0 is a special case: the range is [0,1/64], it is
   evaluated in x=0, and it has only odd coefficients, it has degree 9, and
   it was generated by atan2_0.sollya. The other polynomials are generated
   by Sollya_approx(64,7,1,verbose=true) from atan2.sage.
   These polynomials (at least for i >= 1) are such that the j-th coefficient
   p[i][j] is greater in absolute value than the sum p[i][j+1]*x +
   p[i][j+2]*x^2 + ... for |x| <= 1/128, i.e., when evaluating them using
   Horner's scheme, the condition |a| >= |b| in fast_two_sum is fulfilled. */
static const double Pfast[65][10] = {
  {0, 0, 1.0, 0, 0, -0x1.5555555555555p-2, 0, 0x1.9999999992c29p-3, 0, -0x1.249247c670632p-3 /* , 0, 0x1.c6e5d41706f0dp-4 */ }, /* i=0 71.798 */
  {0x1.7fee0184a5c36p-6, -0x1.43d22cd70f533p-60, 0x1.ffb80a1e93b34p-1, -0x1.46d03098af947p-55, -0x1.7f9416c3bb28ap-6, -0x1.5435ba7ac7b4bp-2, 0x1.7ef26a1277a3dp-6, 0x1.963bcfff26a3bp-3, -0x1.7dfd6148d6a5bp-6, -0x1.201e9fb0fd027p-3}, /* i=1 62.976 */
  {0x1.3fd65f169c9d9p-5, 0x1.6fc5a390a776cp-61, 0x1.ff384e0187672p-1, -0x1.0ba36e06dfbcap-55, -0x1.3f06922fd9dbep-5, -0x1.5238605d11307p-2, 0x1.3d91a94508185p-5, 0x1.904a9cf742939p-3, -0x1.3b6f8b816234cp-5, -0x1.183e25c225415p-3}, /* i=2 63.019 */
  {0x1.bf8ddf139c444p-5, -0x1.8ad3c565de617p-59, 0x1.fe792b3ae6e73p-1, 0x1.c468eda95f788p-55, -0x1.bd5510b2c113bp-5, -0x1.4f40fde893214p-2, 0x1.b95b44f7aca2p-5, 0x1.877aab2d771dcp-3, -0x1.b39bf8a4f8a7bp-5, -0x1.0ca4b8b10bffp-3}, /* i=3 63.055 */
  {0x1.1f86dbf082d59p-4, -0x1.0a6844090e29p-59, 0x1.fd7b301722b81p-1, -0x1.b7c4b456d9f1p-58, -0x1.1d2c5ee4e9befp-4, -0x1.4b55137eb84cdp-2, 0x1.18fa7698d952ep-4, 0x1.7bea5f9a87b2bp-3, -0x1.12f82c7547b43p-4, -0x1.fb24a1e8f998ep-4}, /* i=4 63.101 */
  {0x1.5f2324fd2d7b2p-4, 0x1.89f034812ae7cp-58, 0x1.fc3f18b549418p-1, 0x1.00afc5c42a07p-59, -0x1.5adb99cdd91acp-4, -0x1.467bd93f8f73fp-2, 0x1.53443bd1d3a39p-4, 0x1.6dc1392d00dffp-3, -0x1.487c8d1053674p-4, -0x1.d6b208b39950dp-4}, /* i=5 63.152 */
  {0x1.9e94153cfdcf1p-4, 0x1.a2814938690c5p-58, 0x1.fac5cdace3776p-1, -0x1.c4388d05d39cp-55, -0x1.978c88054ac12p-4, -0x1.40be2665b040ep-2, 0x1.8b26b120d0147p-4, 0x1.5d2ef98a24997p-3, -0x1.79b51526f4a39p-4, -0x1.acb56dcce4cf5p-4}, /* i=6 63.218 */
  {0x1.ddd21701eba6ep-4, 0x1.942d2aa4bb587p-58, 0x1.f9106266112bap-1, 0x1.56a0454b4533ap-56, -0x1.d315457777fe6p-4, -0x1.3a26537a90d91p-2, 0x1.c045a086b6955p-4, 0x1.4a6aa4e4e7f6cp-3, -0x1.a6128dbb72b99p-4, -0x1.7e0b919987108p-4}, /* i=7 63.291 */
  {0x1.0e6adccf40882p-3, -0x1.d7826fb4da63bp-57, 0x1.f720132978badp-1, 0x1.1b41823c3fdc2p-55, -0x1.06a70011b812dp-3, -0x1.32c01802fc58p-2, 0x1.f24deb38dcd5cp-4, 0x1.35b160baffcc4p-3, -0x1.cd1f00d45f80dp-4, -0x1.4ba41d5a77389p-4}, /* i=8 63.373 */
  {0x1.2dcbdb2fba1ffp-3, 0x1.8e4f6ab5e1a94p-58, 0x1.f4f642ee76e94p-1, 0x1.138258ed07804p-55, -0x1.23089b322f78ep-3, -0x1.2a98645802708p-2, 0x1.107b3349ac9d1p-3, 0x1.1f453a05a7f64p-3, -0x1.ee7f64ad21f5ap-4, -0x1.167aa665241c4p-4}, /* i=9 63.473 */
  {0x1.4d087a9da4f17p-3, 0x1.1ec34ee1b5804p-57, 0x1.f29478eeb3352p-1, 0x1.76602e96f901cp-55, -0x1.3e9df6e36e67ep-3, -0x1.21bd38700903dp-2, 0x1.260043570b7fbp-3, 0x1.076bdbe517f54p-3, -0x1.04fa40112f2e7p-3, -0x1.bf1ec6d24067fp-5}, /* i=10 63.584 */
  {0x1.6c1d4898933d9p-3, -0x1.2a337ec184b44p-58, 0x1.effc5e06cfb34p-1, -0x1.57d623c96a6dfp-55, -0x1.5956f0f53a44dp-3, -0x1.183d78655a04p-2, 0x1.399c6a6f83968p-3, 0x1.dcda7fd1cfe9fp-4, -0x1.0fad8c8089fe1p-3, -0x1.4fc17bcce4393p-5}, /* i=11 63.707 */
  {0x1.8b06ee2879c29p-3, -0x1.11fb58ccc22b4p-57, 0x1.ed2fb9ec57f51p-1, -0x1.3bfadbf20c9a6p-55, -0x1.7324d58b40c4ap-3, -0x1.0e28bf8b8a6acp-2, 0x1.4b3b98ee0d9bp-3, 0x1.a924c1a7f814p-4, -0x1.1755afe4dcc0bp-3, -0x1.c193045932f6fp-6}, /* i=12 63.836 */
  {0x1.a9c231b403279p-3, 0x1.0e2051101d4b8p-57, 0x1.ea30704157b4fp-1, 0x1.b10a71f45d3b4p-55, -0x1.8bfa6e285e227p-3, -0x1.038f32e3900dp-2, 0x1.5acf7245187c4p-3, 0x1.7447f06cb0afbp-4, -0x1.1bfbdd3a7739cp-3, -0x1.d01cb4c7be3a8p-7}, /* i=13 63.985 */
  {0x1.c84bf8a742e6ep-3, -0x1.968989ac4b246p-58, 0x1.e7007d8e205eap-1, 0x1.1964d0594119ep-55, -0x1.a3cc0c751a788p-3, -0x1.f102a76f4427bp-3, 0x1.684f3be1ad4f2p-3, 0x1.3ed29cc3090d1p-4, -0x1.1db5775367695p-3, -0x1.6491e54c130dap-10}, /* i=14 64.151 */
  {0x1.e6a148e96ec4dp-3, 0x1.860ad4159da26p-57, 0x1.e3a1f429bd423p-1, -0x1.5e7743342406ep-55, -0x1.ba8f90ce18a18p-3, -0x1.da1fa63927e48p-3, 0x1.73b7b53c7e3c2p-3, 0x1.094e467695623p-4, -0x1.1ca2e645cb80fp-3, 0x1.618b376e792a8p-7}, /* i=15 64.334 */
  {0x1.025fa510665b6p-2, -0x1.675a8ef337f35p-56, 0x1.e016f9196b776p-1, 0x1.205573d9a13f8p-55, -0x1.d03c6cb8472c3p-3, -0x1.c296ce0dbfe5bp-3, 0x1.7d0adb41cc5dep-3, 0x1.a87ad50b8da88p-5, -0x1.18ee465a8217ep-3, 0x1.6a8e00f5842fp-6}, /* i=16 64.533 */
  {0x1.1151a362431cap-2, -0x1.4df150a9ed6ecp-56, 0x1.dc61c0ef1f116p-1, -0x1.fbd1fd5c1e556p-55, -0x1.e4cba1681d227p-3, -0x1.aa89431d9270dp-3, 0x1.844f9995dc4e6p-3, 0x1.4033ab3b632b9p-5, -0x1.12c9e261d1c67p-3, 0x1.0a78fc7f68ba7p-5}, /* i=17 64.752 */
  {0x1.2025567e47c96p-2, -0x1.187a733e2fd4ap-57, 0x1.d8848caeb6c2ap-1, 0x1.20915bb96c5dcp-55, -0x1.f837ba96c2702p-3, -0x1.921795d35217dp-3, 0x1.89916c80d4eebp-3, 0x1.b54d022444b7bp-6, -0x1.0a6ea1928dc1cp-3, 0x1.57245ecb178c3p-5}, /* i=18 64.994 */
  {0x1.2ed987a823cfep-2, 0x1.b8d2b39cce27ap-57, 0x1.d481a6c0fd782p-1, 0x1.2fb4656cb84c5p-55, -0x1.053e62f5c1dd9p-2, -0x1.79617d0ee4253p-3, 0x1.8cdff6758c97cp-3, 0x1.e271cb5a00f62p-7, -0x1.001a6bd96adcap-3, 0x1.9aafbde2911bfp-5}, /* i=19 65.249 */
  {0x1.3d6d129271134p-2, 0x1.1362914968139p-56, 0x1.d05b5ffb0304cp-1, -0x1.faf67bf651fd2p-55, -0x1.0dcc23a49e21fp-2, -0x1.60859757088a3p-3, 0x1.8e4e8c376e12ep-3, 0x1.ac6b469cdc98fp-9, -0x1.e81d29d13c3a6p-4, 0x1.d4bac43f65c1fp-5}, /* i=20 65.563 */
  {0x1.4bdee586890e7p-2, -0x1.e50865cbcaeecp-57, 0x1.cc140cbfae3a7p-1, -0x1.f5190b099884p-60, -0x1.15c4952b34cbp-2, -0x1.47a1337fb3d0cp-3, 0x1.8df3ba9bbd359p-3, -0x1.f213587a92bcbp-8, -0x1.cd1c852733798p-4, 0x1.028e79b3fee1ap-4}, /* i=21 65.916 */
  {0x1.5a2e0175e0f4ep-2, 0x1.13a6a91a764a8p-56, 0x1.c7ae0240b83aep-1, -0x1.84929ee2f31d5p-55, -0x1.1d27d8cdb4d8ep-2, -0x1.2ed02114257ebp-3, 0x1.8be8c8c875f84p-3, -0x1.23ffdc48e4c12p-6, -0x1.afba2bf913442p-4, 0x1.15ef7d9554d9bp-4}, /* i=22 66.347 */
  {0x1.685979f5fa6fep-2, -0x1.25dc3c56dd1fp-59, 0x1.c32b93e386c7fp-1, 0x1.57dc62db0dc4p-56, -0x1.23f6b1ca84e6p-2, -0x1.162c88a71566ep-3, 0x1.884939a10b1dcp-3, -0x1.c0182366f7a2cp-6, -0x1.907b85c4fefcfp-4, 0x1.249bf8e75e9cp-4}, /* i=23 66.846 */
  {0x1.7660752817502p-2, -0x1.dd53027530cap-59, 0x1.be8f10cd9e1fep-1, -0x1.a7f1300ae90b2p-56, -0x1.2a327b0d161d9p-2, -0x1.fb9d9803f90dep-4, 0x1.83324ed94b28bp-3, -0x1.2819be404dc45p-5, -0x1.6fe1e7394650bp-4, 0x1.2ec312a38b33ap-4}, /* i=24 67.512 */
  {0x1.84422b8df95d7p-2, 0x1.d765e81bde4d3p-56, 0x1.b9dac19ba64d6p-1, -0x1.ed559ae54f8p-59, -0x1.2fdd1c390a5c1p-2, -0x1.cb9adc0e99a34p-4, 0x1.7cc28fdb88554p-3, -0x1.69f39154faed7p-5, -0x1.4e68876b64cd6p-4, 0x1.34a4bf4351fdp-4}, /* i=25 68.56 */
  {0x1.91fde7cd0c662p-2, 0x1.1073840f922f8p-56, 0x1.b510e6454751cp-1, -0x1.785b02600928p-62, -0x1.34f8fe3b081f3p-2, -0x1.9c7a03f5e2ed9p-4, 0x1.75195662609b2p-3, -0x1.a57a8f2790cf3p-5, -0x1.2c82d97c3a38bp-4, 0x1.368f01ca8cfddp-4}, /* i=26 71.364 */
  {0x1.9f93066168002p-2, -0x1.c82391f85371ep-56, 0x1.b033b42f6e2c9p-1, -0x1.ea710fd840c44p-57, -0x1.3988ff8a7633ep-2, -0x1.6e60439212c9fp-4, 0x1.6c566252f4071p-3, -0x1.daa48d15a6686p-5, -0x1.0a9b468b4c4b3p-4, 0x1.34d7ee0aa3766p-4}, /* i=27 68.912 */
  {0x1.ad00f5422058bp-2, 0x1.fc52e6394419cp-56, 0x1.ab45546de51cfp-1, -0x1.b70e27dffe78p-58, -0x1.3d906844a38f8p-2, -0x1.416ed5993cbedp-4, 0x1.629976103382ep-3, -0x1.04bd3325f188ep-4, -0x1.d2244b5868804p-5, 0x1.2fe05131f0c4p-4}, /* i=28 68.001 */
  {0x1.ba473378624a5p-2, 0x1.51a3a1ca24953p-56, 0x1.a647e2348d9a3p-1, -0x1.4f623cfe87868p-55, -0x1.4112de46b4ca4p-2, -0x1.15c3010e3d605p-4, 0x1.5801fc2f29caep-3, -0x1.190b04c2a6b8ap-4, -0x1.907a583abf58cp-5, 0x1.280b0dde3049ep-4}, /* i=29 67.537 */
  {0x1.c76550aad71f9p-2, -0x1.74acc61ee02c1p-56, 0x1.a13d6977fc07p-1, -0x1.6c52248551401p-55, -0x1.441459682eef9p-2, -0x1.d6ec52b58dec2p-5, 0x1.4caeb7248540ap-3, -0x1.2a50380bfa7dep-4, -0x1.50ce1c6b4bec7p-5, 0x1.1dbd61de8c0bap-4}, /* i=30 67.248 */
  {0x1.d45aec9ec862bp-2, 0x1.895ce7f329bb8p-57, 0x1.9c27e5bcb52c7p-1, -0x1.92fab46b4bc48p-55, -0x1.469917f43c00bp-2, -0x1.853bcf9f19d52p-5, 0x1.40bd7b3cdb116p-3, -0x1.38a7c5ad9949ap-4, -0x1.139ed999abe43p-5, 0x1.115c0be05198fp-4}, /* i=31 67.125 */
  {0x1.e127b6b0744bp-2, -0x1.2acd0fdf7975p-58, 0x1.97094113dcc5ap-1, -0x1.42a9795ad7bf2p-55, -0x1.48a5937beb903p-2, -0x1.36985a7f2a7e7p-5, 0x1.344af2efd8fe9p-3, -0x1.44321a6832a33p-4, -0x1.b2ac3a28b25a8p-6, 0x1.034919aa579fdp-4}, /* i=32 66.992 */
  {0x1.edcb6d43f8435p-2, -0x1.fc59394a45038p-58, 0x1.91e35343c31e5p-1, -0x1.fd869c730b292p-55, -0x1.4a3e7617d19c1p-2, -0x1.d63da9b55cdfbp-6, 0x1.27726d650bc45p-3, -0x1.4d1415c94be5cp-4, -0x1.44909d78793fcp-6, 0x1.e7c528f25edadp-5}, /* i=33 66.936 */
  {0x1.fa45dd3029259p-2, -0x1.ca45f1fa0d73dp-56, 0x1.8cb7e11a6de8p-1, 0x1.0f9692effe0dcp-57, -0x1.4b68902b948abp-2, -0x1.45caf821fcd46p-6, 0x1.1a4db6d27b1cp-3, -0x1.537613e0921abp-4, -0x1.bad8045dcc6dcp-7, 0x1.c7018191d5ceep-5}, /* i=34 66.898 */
  {0x1.034b709250488p-1, 0x1.8fac2baf4d23cp-56, 0x1.87889be7f594bp-1, -0x1.53b0c2ce0703cp-56, -0x1.4c28ceba4afa2p-2, -0x1.77f13846db057p-7, 0x1.0cf4fa3350aa7p-3, -0x1.57830580a9d19p-4, -0x1.f6688bd6287d1p-8, 0x1.a4eae2b3ff364p-5}, /* i=35 66.895 */
  {0x1.095f30861a59p-1, -0x1.12092ac4be3c2p-56, 0x1.8257211e5c14dp-1, -0x1.e04ad62f66a7cp-56, -0x1.4c84325709c22p-2, -0x1.c6d748a0dc543p-9, 0x1.fefd5770e2195p-4, -0x1.596799b15125ep-4, -0x1.2aa4bf9d8facap-9, 0x1.82163e6e4ba59p-5}, /* i=36 66.885 */
  {0x1.0f5e28b67e295p-1, 0x1.551bae3a62cp-65, 0x1.7d24fa145af59p-1, -0x1.3cc5eac00191cp-55, -0x1.4c7fc6b9bdb53p-2, 0x1.0e125c729c9ccp-8, 0x1.e3fef677f1b61p-4, -0x1.59517a3df2d2fp-4, 0x1.5a509ce09c43cp-9, 0x1.5f093d570a5d7p-5}, /* i=37 66.914 */
  {0x1.154859637646ap-1, -0x1.4b9f306460338p-55, 0x1.77f39be88c85ep-1, -0x1.aaf11fb18ce3p-57, -0x1.4c209afd6bf07p-2, 0x1.724c7fc557881p-7, 0x1.c9149be5b80f4p-4, -0x1.576e9c8b006c6p-4, 0x1.d10ab85893e9fp-8, 0x1.3c397326ee689p-5}, /* i=38 67.0 */
  {0x1.1b1dc87904285p-1, -0x1.21c74a82081f8p-57, 0x1.72c4678244c5ap-1, 0x1.88680c34729b8p-55, -0x1.4b6bba8a3ca51p-2, 0x1.28136c8a3dec7p-6, 0x1.ae607d1bed1bfp-4, -0x1.53eca7421fcc8p-4, 0x1.6b5bcf0c5a74dp-7, 0x1.1a0c6c335db5fp-5}, /* i=39 67.064 */
  {0x1.20de813e823b2p-1, -0x1.79150b1e4ba34p-55, 0x1.6d98a9ad6a3fdp-1, -0x1.086a79e3d623cp-55, -0x1.4a6626ab4a7bep-2, 0x1.905d942e6e222p-6, 0x1.940145f3bf389p-4, -0x1.4ef86cd4bd336p-4, 0x1.df72235053ff2p-7, 0x1.f1b09ca16a18fp-6}, /* i=40 67.101 */
  {0x1.268a940696da6p-1, 0x1.d1712f5892eap-58, 0x1.68719b4ea3592p-1, -0x1.eda97644d9e4p-56, -0x1.4914d0ce1509cp-2, 0x1.f21d69cbf84c5p-6, 0x1.7a122ddea78bbp-4, -0x1.48bd7a5e32406p-4, 0x1.22a2e0cff193bp-6, 0x1.b1c922511e4b9p-6}, /* i=41 67.218 */
  {0x1.2c2215e024466p-1, -0x1.4b0c8f62b19p-59, 0x1.635061ad38dap-1, -0x1.80680c9cf6f14p-57, -0x1.477c9567a666fp-2, 0x1.26b901535afacp-5, 0x1.60ab15199ab1dp-4, -0x1.4165ba0e867bp-4, 0x1.4eb7a8220d45ep-6, 0x1.74d4381fbabb3p-6}, /* i=42 67.326 */
  {0x1.31a52048874bep-1, 0x1.40d189f2ee18fp-55, 0x1.5e360ed021586p-1, 0x1.69f2a21c9feb7p-55, -0x1.45a23779f86ep-2, 0x1.5140026af96e8p-5, 0x1.47e0a87340407p-4, -0x1.39192806876a6p-4, 0x1.744f21ca1f0edp-6, 0x1.3b2a773dcf1c3p-6}, /* i=43 67.434 */
  {0x1.3713d0df6c504p-1, -0x1.4f4269e27352p-58, 0x1.5923a1ebc184fp-1, 0x1.29b1cfdb4f9a3p-55, -0x1.438a5cb2e9ce4p-2, 0x1.78b86fb7fa92ap-5, 0x1.2fc48a4610bc3p-4, -0x1.2ffd9844859a4p-4, 0x1.93c9299bf0eefp-6, 0x1.050c38bb39dc4p-6}, /* i=44 67.52 */
  {0x1.3c6e491c78dc5p-1, -0x1.e13ed2a5d45d7p-55, 0x1.541a07de0a269p-1, 0x1.b8bebc3ed16dfp-55, -0x1.41398a1d19515p-2, 0x1.9d3906bbd6c7ep-5, 0x1.18657f5b9a323p-4, -0x1.26368c2f18148p-4, 0x1.ad8bb799ea9adp-6, 0x1.a549e420d726ep-7}, /* i=45 67.67 */
  {0x1.41b4ae06fea41p-1, 0x1.3d76dfc23f7ccp-57, 0x1.4f1a1bb6bcc2cp-1, 0x1.c6b642e1e7fb8p-58, -0x1.3eb4215a4137ap-2, 0x1.beda3230c472bp-5, 0x1.01cf9e938129bp-4, -0x1.1be5162614e5p-4, 0x1.c20034712fc2ep-6, 0x1.48195f05a1767p-7}, /* i=46 67.845 */
  {0x1.46e727efe4716p-1, -0x1.39a66128d8d94p-57, 0x1.4a24a749c2a47p-1, -0x1.fa101393d28bdp-55, -0x1.3bfe5e5e27a17p-2, 0x1.ddb5b75f1883fp-5, 0x1.d8190485a4ae4p-5, -0x1.1127c985c22e9p-4, 0x1.d191d19f76cd6p-6, 0x1.e52c665933c2p-8}, /* i=47 67.967 */
  {0x1.4c05e22de94e5p-1, -0x1.c0a7876d92182p-55, 0x1.453a63c9a656p-1, 0x1.7a2109be32f3ep-56, -0x1.391c55a0e5b2ep-2, 0x1.f9e669adee0aap-5, 0x1.ae46f4c987cf1p-5, -0x1.061ab5816a7d9p-4, 0x1.dcabb523d989dp-6, 0x1.496609b765f54p-8}, /* i=48 68.158 */
  {0x1.51110adc5ed81p-1, 0x1.23e544f123c74p-56, 0x1.405bfa6864f9p-1, -0x1.42079a05f01c2p-56, -0x1.3611f2bf1f7f5p-2, 0x1.09c3f23e21ce6p-4, 0x1.86337da4370fp-5, -0x1.f5aed2999d562p-5, 0x1.e3b7d41231f7dp-6, 0x1.792d968639b3ep-9}, /* i=49 68.32 */
  {0x1.5608d29c70c34p-1, 0x1.993d4d48d4c64p-55, 0x1.3b8a04fcf28c3p-1, -0x1.6cd902188a2bp-59, -0x1.32e2f77ec4f07p-2, 0x1.155b259c3bdcbp-4, 0x1.5fe541ab2f4bep-5, -0x1.deea00310582dp-5, 0x1.e71d7fcc13a9ep-6, 0x1.f26ee3bf73aa4p-11}, /* i=50 68.482 */
  {0x1.5aed6c5909517p-1, 0x1.7316328459e0cp-55, 0x1.36c50eabf19f5p-1, 0x1.0cc4c93703dep-56, -0x1.2f92fb2f12233p-2, 0x1.1fc707cc3a4f1p-4, 0x1.3b5f771b1f717p-5, -0x1.c81067056654dp-5, 0x1.e74056742f532p-6, -0x1.903173f4bde0fp-11}, /* i=51 68.704 */
  {0x1.5fbf0d0d5cc4ap-1, -0x1.b4b798f4fbecp-58, 0x1.320d949243ad8p-1, -0x1.ce85c7f0fa608p-55, -0x1.2c256a5abec3bp-2, 0x1.2915dee25a8dcp-4, 0x1.18a2454c6953ep-5, -0x1.b146e66e27042p-5, 0x1.e47fdb0d64c7fp-6, -0x1.2a1b98c2588d3p-9}, /* i=52 68.86 */
  {0x1.647deb8e20b9p-1, -0x1.ec8dab63b69ep-58, 0x1.2d6406703b033p-1, 0x1.708a19f93d965p-55, -0x1.289d86c39acffp-2, 0x1.3155e71da961p-4, 0x1.ef563c48c8564p-6, -0x1.9aae01264d404p-5, 0x1.df36b4f1dc171p-6, -0x1.d706f26a461aep-9}, /* i=53 69.101 */
  {0x1.692a40556fb6ap-1, 0x1.d94deb733f4d1p-55, 0x1.28c8c75459603p-1, 0x1.b1a4041ee5c3dp-55, -0x1.24fe679f37471p-2, 0x1.38953e931c5d6p-4, 0x1.b0ea25ecadcccp-6, -0x1.84621a8d1bd9dp-5, 0x1.d7b9f5da3a6a7p-6, -0x1.363048a9835a4p-8}, /* i=54 69.272 */
  {0x1.6dc44551553afp-1, -0x1.bf77d69309b9p-58, 0x1.243c2e44a7335p-1, -0x1.67984277b50a8p-57, -0x1.214afa0ca68dbp-2, 0x1.3ee1d36c0ca2cp-4, 0x1.75f248d7f0eb6p-6, -0x1.6e7bb80f6dcf9p-5, 0x1.ce59773e3cab1p-6, -0x1.75e26f9f73c56p-8}, /* i=55 69.465 */
  {0x1.724c35b4fae7bp-1, 0x1.94999582417c8p-58, 0x1.1fbe86e5ce35dp-1, 0x1.1004ba833cb2dp-55, -0x1.1d8601bbd70fbp-2, 0x1.4449548f48afp-4, 0x1.3e5d1a74014bap-6, -0x1.590fc513ec22ep-5, 0x1.c35f24540e3d9p-6, -0x1.ab6d2714ad386p-8}, /* i=56 69.685 */
  {0x1.76c24dcc6c6cp-1, 0x1.19537fcda06bdp-55, 0x1.1b50121f3f28cp-1, -0x1.5870c87915b8p-59, -0x1.19b219bf87a48p-2, 0x1.48d9248a59eb2p-4, 0x1.0a160eeaeecdbp-6, -0x1.442fd816a4747p-5, 0x1.b70f3c89b3e69p-6, -0x1.d7a2d1bed21d1p-8}, /* i=57 70.196 */
  {0x1.7b26cad2e50fep-1, -0x1.ce7feba9dfb12p-55, 0x1.16f106bbc577ap-1, -0x1.d1017b25ea348p-56, -0x1.15d1b58355b63p-2, 0x1.4c9e4e8fdd57ep-4, 0x1.b20c320c71d8bp-7, -0x1.2fea77c1c2d16p-5, 0x1.a9a815ca7ddc1p-6, -0x1.fb541bbd413c8p-8}, /* i=58 70.555 */
  {0x1.7f79eacb97898p-1, 0x1.fd5d89e91d0ddp-55, 0x1.12a1920604825p-1, -0x1.ccfd3cccb4938p-58, -0x1.11e721dfe6ba7p-2, 0x1.4fa57d5fcbb8dp-4, 0x1.56283e9b7e061p-7, -0x1.1c4b5f1374fd3p-5, 0x1.9b6293a72088cp-6, -0x1.0ba5a5b74340ep-7}, /* i=59 70.763 */
  {0x1.83bbec5cdee22p-1, 0x1.3109d8a8e65ap-57, 0x1.0e61d86071468p-1, -0x1.0ce73a0629f3ap-56, -0x1.0df48647af38dp-2, 0x1.51faf3ef252bdp-4, 0x1.004acd4a116d1p-7, -0x1.095bbfc1aab01p-5, 0x1.8c72288c10abfp-6, -0x1.1625a26153ddbp-7}, /* i=60 71.122 */
  {0x1.87ed0eadc5a2ap-1, 0x1.0af644a40cdf6p-56, 0x1.0a31f5d8701b3p-1, -0x1.69be1c6d2f945p-55, -0x1.09fbe60757b84p-2, 0x1.53aa87a589b39p-4, 0x1.6077cad635afep-8, -0x1.ee45047defbd8p-6, 0x1.7d0507433a359p-6, -0x1.1d87365b117c3p-7}, /* i=61 71.921 */
  {0x1.8c0d9145cf49dp-1, 0x1.bea3f44a38f5p-55, 0x1.0611feb45139ap-1, 0x1.e4854f5cf6588p-56, -0x1.05ff21953a316p-2, 0x1.54bf9c08c1d9dp-4, 0x1.9706e47ec6983p-9, -0x1.cb4905caf6008p-6, 0x1.6d445cd02559ap-6, -0x1.2222e5ddeb73p-7}, /* i=62 72.227 */
  {0x1.901db3eeef187p-1, 0x1.686643d96bf0fp-55, 0x1.0201fffbf7f8p-1, 0x1.0002f3990d4cp-61, -0x1.01fff7ebe8004p-2, 0x1.55451fb001307p-4, 0x1.0509ffc9bc308p-10, -0x1.a9c997dbab5a8p-6, 0x1.5d54a31b98f7dp-6, -0x1.244be978edbbcp-7}, /* i=63 73.347 */
  {0x1.941db699968ffp-1, -0x1.de4c371fb2ddap-55, 0x1.fc03fff80ffp-2, 0x1.f8e5851a6dep-62, -0x1.fc000fd82fff8p-3, 0x1.55458a5aabd48p-4, -0x1.f613ff970b10ap-11, -0x1.89c997e69f2ap-6, 0x1.4d5602132646dp-6, -0x1.244fb6e93a605p-7}, /* i=64 73.751 */
};

/* For 0 <= i <= 64, Xfast[i] is the evaluation point of the polynomial
   Pfast[i]. Except for i=0 where Xfast[i]=0, Xfast[i] is the middle of
   range [i/64,(i+1)/64]. */
static const double Xfast[65] = {0, 0x1.8p-6, 0x1.4p-5, 0x1.cp-5, 0x1.2p-4, 0x1.6p-4, 0x1.ap-4, 0x1.ep-4, 0x1.1p-3, 0x1.3p-3, 0x1.5p-3, 0x1.7p-3, 0x1.9p-3, 0x1.bp-3, 0x1.dp-3, 0x1.fp-3, 0x1.08p-2, 0x1.18p-2, 0x1.28p-2, 0x1.38p-2, 0x1.48p-2, 0x1.58p-2, 0x1.68p-2, 0x1.78p-2, 0x1.88p-2, 0x1.98p-2, 0x1.a8p-2, 0x1.b8p-2, 0x1.c8p-2, 0x1.d8p-2, 0x1.e8p-2, 0x1.f8p-2, 0x1.04p-1, 0x1.0cp-1, 0x1.14p-1, 0x1.1cp-1, 0x1.24p-1, 0x1.2cp-1, 0x1.34p-1, 0x1.3cp-1, 0x1.44p-1, 0x1.4cp-1, 0x1.54p-1, 0x1.5cp-1, 0x1.64p-1, 0x1.6cp-1, 0x1.74p-1, 0x1.7cp-1, 0x1.84p-1, 0x1.8cp-1, 0x1.94p-1, 0x1.9cp-1, 0x1.a4p-1, 0x1.acp-1, 0x1.b4p-1, 0x1.bcp-1, 0x1.c4p-1, 0x1.ccp-1, 0x1.d4p-1, 0x1.dcp-1, 0x1.e4p-1, 0x1.ecp-1, 0x1.f4p-1, 0x1.fcp-1, 0x1.02p+0};

/* For 0 <= i <= 64, err_fast[i] is a bound on the total relative error
   on the range [i/64,(i+1)/64], including the approximation error from
   Pfast[i] and all rounding errors.
   For i=0 the analysis is done in comment in the code below, while for
   1 <= i <= 64 the table was generated by table_err_poly() in atan2pi.sage. */
static const double err_fast[65] = {0x1.aep-65, 0x1.19p-62, 0x1.ap-63, 0x1.61p-63, 0x1.4dp-63, 0x1.3p-63, 0x1.18p-63, 0x1.03p-63, 0x1.ffp-64, 0x1.d5p-64, 0x1.adp-64, 0x1.87p-64, 0x1.63p-64, 0x1.4p-64, 0x1.1dp-64, 0x1.f8p-65, 0x1.bap-65, 0x1.8p-65, 0x1.4bp-65, 0x1.53p-65, 0x1.21p-65, 0x1.e8p-66, 0x1.95p-66, 0x1.5p-66, 0x1.11p-66, 0x1.b4p-67, 0x1.5bp-67, 0x1.89p-67, 0x1.bcp-67, 0x1.e4p-67, 0x1.02p-66, 0x1.07p-66, 0x1.0fp-66, 0x1.1p-66, 0x1.11p-66, 0x1.0dp-66, 0x1.0bp-66, 0x1.06p-66, 0x1.f5p-67, 0x1.e5p-67, 0x1.d9p-67, 0x1.c2p-67, 0x1.adp-67, 0x1.9ap-67, 0x1.8bp-67, 0x1.76p-67, 0x1.5fp-67, 0x1.5p-67, 0x1.3cp-67, 0x1.2dp-67, 0x1.1fp-67, 0x1.0fp-67, 0x1.04p-67, 0x1.edp-68, 0x1.dbp-68, 0x1.c9p-68, 0x1.b7p-68, 0x1.9ap-68, 0x1.8ap-68, 0x1.8p-68, 0x1.74p-68, 0x1.63p-68, 0x1.5dp-68, 0x1.52p-68, 0x1.53p-69};

/* h + l <- bh / ah with relative error bounded by 2^-98.41
   (copied and simplified from tan.c).
   Here is it called with 0 < |bh/ah| <= 1.
   Ensure |l| < 2^-48.999 for 1 <= |ah|, |bh| < 2,
   thus |l| < 2^(e-48.999) when |bh/ah| < 2^e.
   Assumes 2^-1024 < |ah| <= 2^1022, 2^-969 <= |bh|,
   and 2^-969 <= |bh/ah| <= 2^1023.
*/
static void fast_div (double *h, double *l, double bh, double ah)
{
  /* We use here Karp-Markstein's trick for division:
     let b = bh, a = ah, y = o(1/a), and z = o(b*y),
     then the approximation of b/a is z' = z + y*(b-a*z):
     b-a*z' = b-a*(z + y*(b-a*z)) = (b-a*z)*(1-a*y).
     We distinguish two errors:
     * the mathematical error, assuming z + y*(b-a*z) is computed exactly
       (but taking into account that y is not exactly 1/a, and z is not
       exactly b/a
     * the rounding errors in z + y*(b-a*z)
     For the error analysis, we assume 1 <= ah, bh < 2.
  */
  double y = 1.0 / ah;
  /* There is no overflow in y since |ah| > 2^-1024 and
     1/nextabove(2^1024) < DBL_MAX.
     And there is no underflow since |ah| <= 2^1022. */
  /* y = 1/ah / (1 + eps1) with |eps1| < 2^-52.
     |1-ah*y| < |eps1| < 2^-52. */
  *h = bh * y;
  /* The condition 2^-969 <= |bh/ah| <= 2^1023 ensures there is no underflow
     nor overflow, since bh * y = bh/ah / (1 + eps1) with |eps1| < 2^-52. */
  /* h = bh * y / (1 + eps2) with |eps2| < 2^-52
       = bh/ah / (1 + eps1) / (1 + eps2)
     thus writing z = h:
     bh = ah*z * (1 + eps1) * (1 + eps2)
     |bh - ah*z| < ah*z * (eps1 + eps2 + eps1*eps2)
     Since ah < 2 and z <= bh*y < 2, we have:
     |bh - ah*z| < 4 * (2*2^-52 + 2^-104) < 2^-48.999.
     It follows |bh-ah*z'| < (bh-ah*z)*(1-ah*y) < 2^-48.999*2^-52 < 2^-100.999
     Dividing by ah>=1 yields: |bh/ah-z'| < 2^-100.999 too.
     We assume the same bound hold for b,a: |b/a-z'| < 2^-100.999.
  */
  double eh = __builtin_fma (ah, -*h, bh);
  /* The condition 2^-969 <= |bh| ensures that ah*h, which has at most 106
     significant bits, and approximates bh, does not underflow, thus the
     usual error analysis applies. */
  /* from the analysis above, we have |eh| < 2^-48.999 thus the rounding error
     is bounded by ulp(2^-48.999) = 2^-101 */
  *l = y * eh;
  // the condition 2^-969 <= |bh/ah| ensures that l does not underflow
  /* We have y < 1 and |eh| < 2^-48.999, thus |l| < 2^-48.999 and the rounding
     error on l is bounded by ulp(2^-48.999) = 2^-101.
     The total rounding error is thus bounded by:
     2^-101+2^-101 < 2^-100.
     Adding the mathematical error yields:
     2^-100.999 + 2^-100 < 2^-99.41.
     | h + l - (bh + bl) / (ah + al) | < 2^-99.41.

     This was assuming 1 <= a,b < 2, thus with 1/2 <= h+l <= 2.
     For the relative error, this corresponds to 2^-99.41/(1/2) = 2^-98.41
     where 1/2 is the smallest possible value of h+l. */
}

static inline void
fast_two_sum (double *hi, double *lo, double a, double b)
{
  double e;

  *hi = a + b;
  e = *hi - a; /* exact */
  *lo = b - e; /* exact */
}

// same as dd_sum() from atan2.c, for al=0
// assumes |ah| >= |bh|
static inline void
dd_sum1 (double *h, double *l, double ah, double bh, double bl)
{
  fast_two_sum (h, l, ah, bh);
  *l += bl;
}

// Multiply exactly a and b, such that *hi + *lo = a * b.
static inline void a_mul(double *hi, double *lo, double a, double b) {
  *hi = a * b;
  *lo = __builtin_fma (a, b, -*hi);
}

// Multiply a double with a double double : a * (bh + bl)
static inline void s_mul (double *hi, double *lo, double a, double bh,
                          double bl) {
  a_mul (hi, lo, a, bh); /* exact */
  *lo = __builtin_fma (a, bl, *lo);
}

// Returns (ah + al) * (bh + bl) - (al * bl)
// We can ignore al * bl when assuming al <= ulp(ah) and bl <= ulp(bh)
static inline void d_mul(double *hi, double *lo, double ah, double al,
                         double bh, double bl) {
  double s, t;

  a_mul(hi, &s, ah, bh);
  t = __builtin_fma(al, bh, s);
  *lo = __builtin_fma(ah, bl, t);
}

/* Fast path: return err such that |h + l - atan2pi(y,x)| < err*h.
   Assumes 2^-969 < |x|, |y| <= 2^1022 and 2^-969 <= |y/x| <= 2^969
   (conditions needed for fast_div). */
static double atan2pi_fast (double *h, double *l, double y, double x)
{
  d64u64 vy = {.f = y}, vx = {.f = x};
  uint64_t ay = vy.u << 1, ax = vx.u << 1;
  int inv = ay > ax, negx = vx.u >> 63, negz = (vy.u ^ vx.u) >> 63;
  if (inv) { double t = y; y = x; x = t; }
  // now |y| <= |x|
  double zh, zl;
  if (__builtin_expect (ax == ay, 0)) { // avoid spurious inexact
    if (y == x)
      *h = (x > 0) ? 0.25 : -0.75;
    else
      *h = (x > 0) ? -0.25 : 0.75;
    *l = 0;
    return 0; // exact
  }
  fast_div (&zh, &zl, y, x);
  // for |zh| < 2^e, we have |zl| < 2^(e-48.999)
  /* since |y| <= |x| and fast_div ensures |zl| < 2^-47.999 with relative
     error < 2^-98.41, we have |zh+zl| < 1 + 2^-98.41, thus
     |zh| < 1 + 2^-98.41 - 2^-47.999 < 1 + 1/64, thus i <= 64 below */

  // zh + zl = y/x * (1 + eps1) with |eps1| < 2^-98.41
  // the rational approximation is only for z > 0, it is not antisymmetric
  double sz = 1.0;
  if (zh < 0) { zh = -zh; zl = -zl; sz = -1.0; }

  // now approximate atan(zh+zl) for 0 <= zh+zl < 1
  int i = __builtin_trunc (64.0 * zh); // 0 <= i <= 64
  const double *p = Pfast[i];
  zh -= Xfast[i];
#define P9 0x1.c6e5d41706f0dp-4 // degree-9 coefficient for i=0
  double z = zh + zl, t;
  *h = (i == 0) ? __builtin_fma (P9, z * z, p[9]) : p[9];
  for (int j = 6; j >= 2; j--)
    *h = __builtin_fma (*h, z, p[2+j]); // degree j
  // degree 1: h + l <- h * (zh + zl) + p[2] + p[3]
  s_mul (h, l, *h, zh, zl);
  fast_two_sum (h, &t, p[2], *h);
  *l += t + p[3];
  // degree 0: h + l <- (h + l) * (zh + zl) + p[0] + p[1]
  d_mul (h, l, *h, *l, zh, zl);
  // for i=0 we have p[0]=0, but fast_two_sum works in that case
  fast_two_sum (h, &t, p[0], *h);
  *l += t + p[1];

  /* Special error analysis for i=0 (0 < z < 2^-6):
     (1) the routine Err_poly0(71.798,e0=-34,K=8) in atan2.sage shows
         that for 2^-35 <= z < 2^-6, the relative error is bounded
         by 4.55142303056794?e-20 < 0x1.aep-65.
     (2) it thus suffices to analyze what happens for z < 2^-35,
         where z = zh+zl. Assume 2^(e-1) <= |z| < 2^e with e <= -35;
         After h = fma(P9,z*z,p[9]) we have |h| < 2^-2.
         For j=6 after h = fma(h,z,p[2+j]) since p[8]=0 we have |h| < 2^(e-2).
         For j=5 after h = fma(h,z,p[2+j]): |h| < 2^(e-2)*2^e+p[7] < 2^-2.
         For j=4 after h = fma(h,z,p[2+j]) since p[6]=0 we have |h| < 2^(e-2).
         For j=3 after h = fma(h,z,p[2+j]): |h| < 2^(e-2)*2^e+p[5] < 2^-1,
         with h negative.
         For j=2 after h = fma(h,z,p[2+j]) since p[4]=0 we have |h| < 2^(e-1),
         with h still negative.
         After s_mul (h, l, *h, zh, zl) we have -2^-71 < h < 0 and
         |l| < ulp(h) <= 2^-124.
         Since p[2]=1, fast_two_sum (h, t, p[2], *h) gives
         |h + t - 1| < 2^-71 + 2^-105 < 2^-70.999 with |t| < 2^-52.
         Since p[3]=0 after *l += t + p[3], the value of l differ from t by
         at most the initial value of l and the rounding error on l + t:
         |l-t| <= 2^-124 + ulp(2^-52) = 2^-124 + 2^-104 <= 2^-103.999,
         thus |h + l - 1| < 2^-70.999 + 2^-103.999 < 2^-70.998.
         The d_mul (h, l, *h, *l, zh, zl) call decomposes into:
           a_mul(h, s, h_in, zh)
           u = __builtin_fma(l_in, zh, s)
           l = __builtin_fma(h_in, zl, u)
         with error bounded by:
         |h + l - (h_in+l_in)*(zh+zl)| < ulp(u) + ulp(l) + |l_in|*|zl|
         Since |h_in| <= 1, |zh| < 2^e, we have |h| < 2^e and |s| < 2^(e-53).
         Since |zh| < 2^e, |l_in| <= 2^-52, and |s| < 2^(e-53), we have
         |u| < 2^(e-51.4) thus ulp(u) <= 2^(e-104).
         Now |h_in| <= 1, |zl| <= 2^(e-48.999), |u| < 2^(e-51.4) thus
         |h_in * zl + u| < 2^(e-48.7) thus ulp(l) <= 2^(e-101).
         In summary:
         |h+l-(h_in+l_in)*(zh+zl)| < 2^(e-104) + 2^(e-101) + 2^-52*2^(e-48.999)
                                   < 2^(e-99.912).
         Since |h_in + l_in - 1| < 2^-70.998 this gives:
         |h + l - (zh + zl)| < 2^(e-99.912) + 2^-70.998*2^e < 2^(e-70.997).
         Since p[0]=p[1]=0 these values are not modified by the last two
         instructions fast_two_sum (h, t, p[0], *h) and *l += t + p[1].
         Since |atan(z) - z| <= z^3/3 for 0 <= z <= 1/2, we deduce:
         |h + l - atan(z)| < 2^(e-70.997) + z^3/3
                           < 2^(e-70.997) + 2^e*2^-70/3 < 2^(e-70.261). [*]
         Now |z - y/x| < 2^-98.41*|y/z| thus since atan(z) is contracting:
         |atan(z) - atan(y/x)| < 2^-98.41*|y/x|,
         and since z/atan(z) < 1.001 for |z| < 2^-35:
         |atan(z) - atan(y/x)| < 2^-98.41*1.001*atan(y/x) < 2^-98.4*atan(y/x).
         Reporting into [*] yields:
         |h + l - atan(y/x)| < 2^(e-70.261) + 2^-98.4*atan(y/x).
         Since 2^(e-1) <= z:
         |h + l - atan(y/x)| < 2^-69.261*z + 2^-98.4*atan(y/x).
         And since |z| < y/x*(1 + 2^-98.41):
         |h + l - atan(y/x)| < 2^-69.260*y/x + 2^-98.4*atan(y/x).
         Now since y/z <= 1.001*atan(y/x) for y/x < 2^-35:
         |h + l - atan(y/x)| < 2^-69.258*atan(y/x) + 2^-98.4*atan(y/x).
                             < 2^-69.257*atan(y/x).
         Thus the relative error is bounded by 2^-69.257 for z < 2^-35.
         Since this is smaller than the bound for 2^-35 <= z < 2^-6, the
         latter bound applies in all cases: for i=0 (0 < z < 2^-6), the
         relative error is bounded by 0x1.adp-65.
  */

  // atan2pi_begin
  // divide by pi
  d_mul (h, l, *h, *l, ONE_OVER_PI_H, ONE_OVER_PI_L);
  /* We had h_in + l_in = atan(y/x) * (1 + eps) with |eps| < eps[i].
     ONE_OVER_PI_H+ONE_OVER_PI_L = 1/pi * (1 + eps2) with |eps2| < 2^-107.871.
     For i=0 we have |l_in| < 2^(e-48.7) [see max_l() in atan2.sage]
     with 2^(e-1) < z < 2^e, thus since z < 1.0001*atan(z):
     |l_in| < 1.0001*2^-47.7*|h_in|, thus |l_in| < 2^-47.699*|h_in|,
     In the other cases (1 <= i < 64) [see max_l() in atan2.sage]
     we have |l_in| < 3.41711218583539e-17 thus since atan(z) >= atan(1/6)
     this yields |l_in| < 2^-52.101*|h_in|.
     In all cases we have |l_in| < 2^-47.699*|h_in|.

     The ignored term l_in*ONE_OVER_PI_L in d_mul() thus has a contribution
     less than 2^-47.699*|ONE_OVER_PI_L/ONE_OVER_PI_H| < 2^-101.543 with
     respect to the product h+l.

     The d_mul() call decomposes into:
     a_mul(h, s, h_in, ONE_OVER_PI_H)
     t = __builtin_fma(l_in, ONE_OVER_PI_H, s)
     l = __builtin_fma(h_in, ONE_OVER_PI_L, t)
     The first rounding error is bounded by ulp(t). We have |s| < ulp(h)
     thus |s| < 2^-52*|h|. And |l_in| < 2^-47.699*|h_in| thus
     |l_in*ONE_OVER_PI_H| < 2^-47.699*|h|. This yields
     |t| < 2^-47.627*|h|, thus ulp(t) < 2^-99.627*|h|.
     The second rounding error is bounded by ulp(l). We have
     |t| < 2^-47.627*|h| and |ONE_OVER_PI_L| < 2^-53.844*ONE_OVER_PI_H,
     thus |l| < (2^-53.844+2^-47.627)*|h| < 2^-47.607*|h| thus
     ulp(l) < 2^-99.607*|h|.
     The relative error of d_mul() is thus bounded by:
     2^-99.627 + 2^-99.607 < 2^-98.616.

     In summary:
     h_in + l_in = atan(y/x) * (1 + eps) with |eps| < eps[i],
     ONE_OVER_PI_H+ONE_OVER_PI_L = 1/pi * (1 + eps2) with |eps2| < 2^-107.871,
     h+l = (h_in + l_in)*(ONE_OVER_PI_H+ONE_OVER_PI_L) * (1 + eps3)
           with |eps3| < 2^-98.616, thus:
     h+l = atan(y/x)/pi * (1+eps'[i])
     with eps'[i] < (1+eps[i])*(1+2^-107.871)*(1+2^-98.616)-1.
  */
  // atan2pi_end

  // restore sign
  *h *= sz;
  *l *= sz;

  // atan2pi_begin
  // now -1/4 < h+l < 1/4
  if (inv)
  {
    if (!negz)
      /* if y/x > 0 thus atanpi(y/x) > 0 we apply 1/2 - atanpi(y/x)
         and the result will be in (1/4, 1/2) */
      dd_sum1 (h, l, 0.5, -*h, -*l);
    /* Assume the relative error on h_in+l_in is bounded by eps'[i].
       Since |h_in+l_in| < 1/4 the absolute error is bounded by eps'[i]/4.
       Since 0 - l_in is exact, the error on dd_sum1() is bounded by
       2^-105*|h_out| + ulp(l_out).
       Now |l_out| < ulp(h_out) + |l_in| <= ulp(h_out) + 2^-47.607*|h_in|
       [see above] <= ulp(1/2) + 2^-47.607*1/4 < 2^-49.4,
       thus ulp(l_out) <= 2^-102, and 2^-105*|h_out| < 2^-106.
       The absolute error is thus bounded by:
       eps'[i]*1/4 + 2^-106 + 2^-102.
       Since h_out+l_out>=1/4, the relative error is bounded by:
       eps'[i] + (2^-106 + 2^-102)/(1/4) < eps'[i] + 2^-99.912. */
    else
      /* if y/x < 0 thus atanpi(y/x) < 0 we apply -1/2 - atanpi(y/x)
         and the result will be in (-1/2,-1/4) */
      // the same error analysis as above applies: the relative error is
      // bounded by eps'[i] + 2^-99.912
      dd_sum1 (h, l, -0.5, -*h, -*l);
  }
  // now -1/2 <= h+l <= 1/2 with error bounded by eps'[i] + 2^-99.912
  if (negx)
  {
    if (!negz)
      /* 1st quadrant -> 3rd quadrant (subtract 1), and the result
         will be in (-1,-1/2) */
      dd_sum1 (h, l, -1.0, *h, *l);
    /* The relative error on h_in+l_in is bounded by eps'[i] + 2^-99.912.
       Since |h_in+l_in| < 1/2 the absolute error is bounded by
       (eps'[i] + 2^-99.912)/2.
       The error on dd_sum1() is bounded by: 2^-105*|h| + ulp(l).
       Since |h| <= 1, 2^-105*|h| <= 2^-105.
       Now |l| < ulp(h) + |l_in|. 
       Since |l_in| < 2^-47.607*|h_in| [see above], and |h_in| <= 1/2,
       we have |l_in| < 2^-48.607 thus |l| < ulp(1) + 2^-48.607 < 2^-48.4,
       and ulp(l) <= ulp(2^-48.4) = 2^-101.
       The absolute error is thus bounded by:
       (eps'[i] + 2^-99.912)*1/2 + 2^-105 + 2^-101.
       Since h+l>1/2, the relative error is bounded by:
       eps'[i] + 2^-99.912 + (2^-105 + 2^-101)/(1/2)
              < eps'[i] + 2^-98.912. */
    else
      /* 4th quadrant -> 2nd quadrant (add 1), and the result will be
         in (1/2,1) */
      // the same error analysis as above applies: the relative error is
      // bounded by eps[i] + 2^-98.912
      dd_sum1 (h, l, 1.0, *h, *l);
  }
  // atan2pi_end
  return err_fast[i];
}

// atan(y/x)
double __atan2pi (double y, double x)
{
  d64u64 uy = {.f = y}, ux = {.f = x};
  uint64_t ay = uy.u & MASK, ax = ux.u & MASK;
  int ey = ay >> 52, ex = ax >> 52;

  if (__builtin_expect (ey == 0x7ff || ex == 0x7ff, 0)) // NaN or Inf
  {
    if (is_nan (ay) || is_nan (ax))
      return y + x; // if y or x is sNaN, returns qNaN and raises invalid
    // Now neither y nor x is NaN, but at least one is +Inf or -Inf
    if (is_inf (ay) && is_inf (ax)) // both y and x are +/-Inf
    {
      // atan2pi (+/-Inf,-Inf) = +/-3/4
      if (x < 0)
        return (y > 0) ? 0.75 : -0.75; // atan2pi_specific
      // atan2pi (+/-Inf,+Inf) = +/-1/4
      return (y > 0) ? 0.25 : -0.25;   // atan2pi_specific
    }
    // now only one of y and x is +/-Inf
    if (is_inf (ax))
    {
      if (x < 0)
        return (uy.u >> 63) ? -1.0 : 1.0; // atan2pi_specific
      // atan2pi(+/-0,x) = +/-0 for x > 0
      // atan2pi(+/-y,+Inf) = +/-0 for finite y>0
      return __builtin_copysign (0, y);
    }
    // now y = +/-Inf
    // atan2pi(+/-Inf,x) = +/-1/2 for finite x
    return (y > 0) ? 0.5 : -0.5; // atan2pi_specific
  }

  if (__builtin_expect (ay == 0 || ax == 0, 0))
  {
    if (ay == 0 && ax == 0)
    {
      if (ux.u == 0) // atan2pi(+/-0, +0) = +/-0
        return y;
      // atan2pi(+/-0, +0) = +/-1
      return (uy.u == 0) ? 1 : -1; // atan2pi_specific
    }
    // only one of y and x is zero
    if (ay == 0)
    {
      // atan2pi(+/-0,x) = +/-0 for x>0
      if (x > 0) return y;
      // atan2pi(+/-0,x) = +/-1 for x<0
      return (uy.u == 0) ? 1.0 : -1.0;
    }
    // now only x is zero
    // atan2pi(y,+/-0) = -1/2 for y<0
    // atan2pi(y,+/-0) = +1/2 for y>0
    return (y > 0) ? 0.5 : -0.5; // atan2pi_specific
  }

  // now both y and x are neither NaN, nor +/-Inf, nor +/-0

  /* atan2pi_fast requires 2^-969 <= |x|, |y| <= 2^1022
     and 2^-969 <= |y/x| < 2^969 */
  // 2^-969 <= |x| <= 2^1022 translates into 54 <= ex <= 2044
  /* |ey - ex| <= 341 avoids spurious underflow in the fast path,
     since we multiply a term of order z by another of order z^2,
     where z = min(|y/x|,|x/y|) */
  if (__builtin_expect (54 <= ex && ex <= 2044 && 54 <= ey && ey <= 2044 &&
                        -341 <= ey - ex && ey - ex <= 341, 1))
  {
    double h, l, err;
    err = atan2pi_fast (&h, &l, y, x);
    double left =  h + __builtin_fma (h, -err, l);
    double right = h + __builtin_fma (h, +err, l);
    if (__builtin_expect (left == right, 1))
      return left;
  }

  return atan2pi_accurate (y, x);
}
libm_alias_double (__atan2pi, atan2pi)
