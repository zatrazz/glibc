/* Correctly rounded base-10 logarithm of binary64 values.

Copyright (c) 2022-2025 INRIA and CERN.
Authors: Paul Zimmermann and Tom Hubrecht.

This file is part of the CORE-MATH project
(https://core-math.gitlabpages.inria.fr/).

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#include <errno.h>
#include <math.h>
#include <stdint.h>
#include <libm-alias-finite.h>
#include "math_config.h"
#include "dint.h"
#include "e_log_data.h"
#define CORE_MATH_SUPPORT_ERRNO

typedef union { double f; uint64_t u; } d64u64;

/* Add a + b, such that *hi + *lo approximates a + b.
   Assumes |a| >= |b|.  */
static void
fast_two_sum (double *hi, double *lo, double a, double b)
{
  double e;

  *hi = a + b;
  e = *hi - a; /* exact */
  *lo = b - e; /* exact */
  /* Now hi + lo = a + b exactly for rounding to nearest.
     For directed rounding modes, this is not always true.
     Take for example a = 1, b = 2^-200, and rounding up,
     then hi = 1 + 2^-52, e = 2^-52 (it can be proven that
     e is always exact), and lo = -2^52 + 2^-105, thus
     hi + lo = 1 + 2^-105 <> a + b = 1 + 2^-200.
     A bound on the error is given
     in "Note on FastTwoSum with Directed Roundings"
     by Paul Zimmermann, https://hal.inria.fr/hal-03798376, 2022.
     Theorem 1 says that
     the difference between a+b and hi+lo is bounded by 2u^2|a+b|
     and also by 2u^2|hi|. Here u=2^-53, thus we get:
     |(a+b)-(hi+lo)| <= 2^-105 min(|a+b|,|hi|) */
}

/* The following is a degree-6 polynomial approximating log(1+x) over
   [-0.00202941894531250,0.00212097167968735].
   It was generated by Sollya, which claims
   an absolute error < 2^-70.278 (see file P.sollya).
   The polynomial is P[0]*x + P[1]*x^2 + ... + P[5]*x^6.
   The algorithm assumes that P[0]=1. */
static const double P[6] = {0x1p0,                 /* degree 1 */
                            -0x1.ffffffffffffap-2, /* degree 2 */
                            0x1.555555554f4d8p-2,  /* degree 3 */
                            -0x1.0000000537df6p-2, /* degree 4 */
                            0x1.999a14758b084p-3,  /* degree 5 */
                            -0x1.55362255e0f63p-3, /* degree 6 */
};

// Multiply exactly a and b, such that *hi + *lo = a * b.
static inline void a_mul(double *hi, double *lo, double a, double b) {
  *hi = a * b;
  *lo = __builtin_fma(a, b, -*hi);
}

// Returns (ah + al) * (bh + bl) - (al * bl)
// We can ignore al * bl when assuming al <= ulp(ah) and bl <= ulp(bh)
static inline void d_mul(double *hi, double *lo, double ah, double al,
                         double bh, double bl) {
  double s, t;

  a_mul(hi, &s, ah, bh); /* exact */
  t = __builtin_fma(al, bh, s);
  *lo = __builtin_fma(ah, bl, t);
}

/* Given 1 <= x := v.f < 2, where x = v.f, put in h+l a double-double
   approximation of log10(2^e*x), with absolute error bounded by 2^-69.14
   (details below).
*/
static void
cr_log10_fast (double *h, double *l, int e, d64u64 v)
{
  uint64_t m = v.u & 0xfffffffffffff;
  /* x = m/2^52 */
  /* if x > sqrt(2), we divide it by 2 to avoid cancellation */
  int c = m >= 0x6a09e667f3bcd;
  /* normalize v in [1/sqrt(2),sqrt(2)) */
  v.u = ((0x3ffull - c) << 52) + m;
  e += c; /* now -1074 <= e <= 1024 */
  double y = v.f;
  uint64_t em = 0x10000000000000 + m;
  int i = em >> (43 + c);
#define OFFSET 362
  double r = _INVERSE[i-OFFSET];
  double l1 = _LOG_INV[i-OFFSET][0];
  double l2 = _LOG_INV[i-OFFSET][1];
  double z = __builtin_fma (r, y, -1.0); /* exact */
  /* evaluate P(z), for |z| < 0.00212097167968735 */
  double ph; /* will hold the value of P(z)-z */
  double z2 = z * z; /* |z2| < 4.5e-6 thus the rounding error on z2 is
                        bounded by ulp(4.5e-6) = 2^-70. */
  double p45 = __builtin_fma (P[5], z, P[4]);
  /* |P[5]| < 0.167, |z| < 0.0022, |P[4]| < 0.21 thus |p45| < 0.22:
     the rounding error on p45 is bounded by ulp(0.22) = 2^-55.
     This rounding error is multiplied by z^5 below, thus contributes to at
     most z^5*2^-55 < 2^-99.4. */
  double p23 = __builtin_fma (P[3], z, P[2]);
  /* |P[3]| < 0.26, |z| < 0.0022, |P[2]| < 0.34 thus |p23| < 0.35:
     the rounding error on p23 is bounded by ulp(0.35) = 2^-54.
     This rounding error is multiplied by z^3 below, thus contributes to at
     most z^3*2^-54 < 2^-80.6. */
  ph = __builtin_fma (p45, z2, p23);
  /* |p45| < 0.22, |z2| < 4.5e-6, |p23| < 0.35 thus |ph| < 0.36:
     the rounding error of this fma is bounded by ulp(0.36) = 2^-54.
     In addition, we should count the rounding error on z2 multiplied by p45,
     which is bounded by 2^-70*0.22 < 2^-72.1.
     This yields a total error on ph < 2^-54+2^-72.1 < 2^-53.99.
     This error is multiplied by z^3 below, thus contributes to at
     most z^3*2^-53.99 < 2^-80.6. */
  ph = __builtin_fma (ph, z, P[1]);
  /* let ph0 be the value at input, and ph1 the value at output:
     |ph0| < 0.36, |z| < 0.0022, |P[1]| < 0.5 thus |ph1| < 0.501:
     the rounding error on ph1 is bounded by ulp(0.501) = 2^-53.
     This error is multiplied by z^2 below, thus contributes to at
     most z^2*2^-53 < 2^-70.76. */
  ph *= z2;
  /* let ph2 be the value at output of the above instruction:
     |ph2| < |z2| * |ph1| < 4.5e-6 * 0.501 < 2.26e-6 thus the
     rounding error on ph2 is bounded by ulp(2.26e-6) = 2^-71.
     In addition we have the rounding error on z2 multiplied by ph1,
     which gives 0.501*2^-70 < 2^-70.99.
     The total error for this instruction is 2^-71+2^-70.99 < 2^-69.99. */

  /* Add e*log(2) to (h,l), where -1074 <= e <= 1023, thus e has at most
     11 bits. log2_h is exactly representable on 42 bits, so that e*log2_h
     is exact. */
  static const double log2_h = 0x1.62e42fefa38p-1,
    log2_l = 0x1.ef35793c7673p-45;
  /* |log(2) - (h+l)| < 2^-102.01 */
  /* let hh = e * log2_h: hh is an integer multiple of 2^-42,
     with |hh| <= 1074*log2_h
     = 3274082061039582*2^-42. l1 is also an integer multiple of 2^-42,
     with |l1| <= 1524716581803*2^-42. Thus hh+l1 is an integer multiple of
     2^-42, with 2^42*|hh+l1| <= 3275606777621385 < 2^52, thus hh+l1 is exactly
     representable. */

  double ee = e;
  fast_two_sum (h, l, __builtin_fma (ee, log2_h, l1), z);
  /* here the fma() instruction is exact (see above),
     and |hh+l1|+|z| <= 3275606777621385*2^-42 + 0.0022 < 745
     thus |h| < 745, and the rounding error from the fast_two_sum() call is
     bounded by 2^-105*745 < 2^-95.4. */
  /* add ph + l2 to l */
  *l = ph + (*l + l2);
  /* here |ph| < 2.26e-6, |l| < ulp(h) = 2^-43, and |l2| < 2^-43,
     thus |*l + l2| < 2^-42, and the rounding error on *l + l2 is bounded
     by ulp(2^-43) = 2^-95 (*l + l2 cannot be > 2^-42).
     Now |ph + (*l + l2)| < 2.26e-6 + 2^-42 < 2^-18.7, thus the rounding
     error on ph + ... is bounded by ulp(2^-18.7) = 2^-71, which yields a
     cumulated error bound of 2^-95 + 2^-71 < 2^-70.99 for this instruction. */

  *l = __builtin_fma (ee, log2_l, *l);
  /* let l_in be the input value of *l, and l_out the output value.
     We have |l_in| < 2^-18.7 (from above)
     and |e*log2_l| <= 1074*0x1.ef35793c7673p-45
     thus |l_out| < 2^-18.69 and err(l_out) <= ulp(2^-18.69) = 2^-71 */

  /* The absolute error on h + l is bounded by:
     2^-70.278 from the error in the Sollya polynomial
     2^-99.4 for the rounding error in p45
     2^-80.6 for the rounding error in p23
     2^-80.6 for the rounding error in the first ph value
             approximating P[2]+z*P[3]+z^2*P[4]+z^3*P[5]
     2^-70.76 for the rounding error in the second ph value
             approximating P[1]+z*P[2]+...+z^4*P[5]
     2^-69.99 for the rounding error in ph *= z2
     2^-91.94 for the maximal difference |e*(log(2)-(log2_h + log2_l))|
              (|e| <= 1074 and |log(2)-(log2_h + log2_l)| < 2^-102.01)
     2^-97 for the maximal difference |l1 + l2 - (-log(r))|
     2^-95.4 from the fast_two_sum call
     2^-70.99 from the *l = ph + (*l + l2) instruction
     2^-71 from the last __builtin_fma call.
     This gives an absolute error bounded by < 2^-68.22.
  */
  
  /* Divide h+l by log(10), by multiplying by approximation of 1/log(10). */
#define ONE_OVER_LOG10_H 0x1.bcb7b1526e50ep-2
#define ONE_OVER_LOG10_L 0x1.95355baaafad3p-57
  /* |1/log(10) - (ONE_OVER_LOG10_H + ONE_OVER_LOG10_L)| < 2^-111.05 */

  d_mul (h, l, *h, *l, ONE_OVER_LOG10_H, ONE_OVER_LOG10_L);
  /* We have the following errors:
     - the error on h_in + l_in multiplied by ONE_OVER_LOG10_H+ONE_OVER_LOG10_L
       which yields 2^-68.22*(ONE_OVER_LOG10_H+ONE_OVER_LOG10_L) < 2^-69.42
     - the approximation error on ONE_OVER_LOG10_H+ONE_OVER_LOG10_L multiplied
       by h_in + l_in, which yields 2^-111.05*(745+2^-18.7) < 2^-101.5
     - the neglected term l_in * ONE_OVER_LOG10_L in d_mul(), which is bounded
       by 2^-18.7 * ONE_OVER_LOG10_L < 2^-75.03
     - the rounding errors of the two fma() in d_mul(), which decomposes in:
       a_mul (hi, s, h_in, ONE_OVER_LOG10_H) [exact]
       t = __builtin_fma (l_in, ONE_OVER_LOG10_H, s)
       l = __builtin_fma (h_in, ONE_OVER_LOG10_L, t)
       since |h_in| < 745, we have |h| <= o(745*ONE_OVER_LOG10_H) < 324,
       and thus |s| < ulp(h) <= 2^-44.
       Then since |l_in| < 2^-18.69, we have
       |t| < 2^-18.69*ONE_OVER_LOG10_H+2^-44 < 2^-19.89, thus the rounding
       error in the first fma is bounded by ulp(2^-19.89) = 2^-72. Then
       |l| < 745*ONE_OVER_LOG10_L+2^-19.89 < 2^-19.88, and the rounding error
       in the second fma is bounded by ulp(2^-19.88) = 2^-72 too.
       This gives a bound of 2^-71 for the rounding errors of the two fma's.

     This yields a total absolute error bounded by
     2^-69.42 + 2^-101.5 + 2^-75.03 + 2^-71 < 2^-68.98.
   */
}

static void accurate_log (dint64_t *r, dint64_t *x);

/*
  Accurate path, using Tom Hubrecht's code below (adapted for log10).
*/
static double
cr_log10_accurate (double x)
{
  dint64_t X, Y;
  dint_fromd (&X, x, 0x3ff);
  /* x = (-1)^sgn*2^ex*(hi/2^63+lo/2^127) */
  accurate_log (&Y, &X);
  /* multiply by 1/log(10) */
  mul_dint_126 (&Y, &ONE_OVER_LOG10, &Y);
  return dint_tod_not_subnormal (&Y);
}

double
__ieee754_log10 (double x)
{
  d64u64 v = {.f = x};
  int e = (v.u >> 52) - 0x3ff;
  if (e >= 0x400 || e == -0x3ff) /* x <= 0 or NaN/Inf or subnormal */
  {
    static const d64u64 minf = {.u = 0xfffull << 52};
    if (e == 0x400 || (e == 0xc00 && x != minf.f)) /* +Inf or NaN */
      return x + x;
    if (x <= 0.0)
    {
      /* log10(x<0) is NaN, f(+/-0) is -Inf and raises DivByZero */
      if (x < 0) {
#ifdef CORE_MATH_SUPPORT_ERRNO
        errno = EDOM;
#endif
        return 0.0 / 0.0;
      }
      else {
#ifdef CORE_MATH_SUPPORT_ERRNO
        errno = ERANGE; // pole error
#endif
        return 1.0 / -0.0;
      }
    }
    if (e == -0x3ff) /* subnormal */
    {
      v.f *= 0x1p52;
      e = (v.u >> 52) - 0x3ff - 52;
    }
  }

  static const double pow10[32] =
    { 0x1p+0, 0x1.4p+3, 0x1.9p+6, 0x1.f4p+9, 0x1.388p+13, 0x1.86ap+16,
      0x1.e848p+19, 0x1.312dp+23, 0x1.7d784p+26, 0x1.dcd65p+29,
      0x1.2a05f2p+33, 0x1.74876e8p+36, 0x1.d1a94a2p+39,
      0x1.2309ce54p+43, 0x1.6bcc41e9p+46, 0x1.c6bf52634p+49,
      0x1.1c37937e08p+53, 0x1.6345785d8ap+56, 0x1.bc16d674ec8p+59,
      0x1.158e460913dp+63, 0x1.5af1d78b58c4p+66, 0x1.b1ae4d6e2ef5p+69,
      0x1.0f0cf064dd592p+73, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  const uint64_t *pow10u = (uint64_t*)pow10;

  /* For x = 10^n for 0 <= n <= 22 we should
     return n without a spurious inexact exception. */
  unsigned int n = 0x267cfa2u*((unsigned int)e+1u)>>27;
  if(__builtin_expect(v.u == pow10u[n], 0)) return n;

  /* now x > 0 */
  double h, l;
  cr_log10_fast (&h, &l, e, v);

  /* Maximal absolute error from cr_log10_fast: 2^-68.98 < 1.04p-69.
     This bound is relatively tight, since for 0x1.59p-70 it fails
     for x=0x1.8301ae420f027p+864 (rndz). */
  static const double err = 0x1.04p-69;

  double left = h + (l - err), right = h + (l + err);
  if (left == right) return left;

  /* the probability of failure of the fast path is about 2^-11.5 */
  return cr_log10_accurate (x);
}
libm_alias_finite (__ieee754_log10, __log10)

// Approximation for the second iteration
static inline void p_2(dint64_t *r, dint64_t *z) {
  cp_dint(r, &P_2[0]);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[1], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[2], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[3], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[4], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[5], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[6], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[7], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[8], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[9], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[10], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[11], r);

  mul_dint_126(r, z, r);
  add_dint(r, &P_2[12], r);

  mul_dint_126(r, z, r);
}


static void accurate_log (dint64_t *r, dint64_t *x) {
  int64_t E = x->ex;

  // Find the lookup index
  uint16_t i = x->hi >> 55;

  if (x->hi > 0xb504f333f9de6484) {
    E++;
    i = i >> 1;
  }

  x->ex = x->ex - E;

  dint64_t z;
  mul_dint_126(&z, x, &_INVERSE_2[i - 128]);

  add_dint(&z, &M_ONE, &z);

  // EÂ·log(2)
  mul_dint_2(r, E, &LOG2);

  dint64_t p;

  p_2(&p, &z);

  add_dint(&p, &_LOG_INV_2[i - 128], &p);

  add_dint(r, &p, r);
}
